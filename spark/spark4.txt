RDD对应一个task,题得分去对应的task只能在一台机器里面(在executor),一台机器上可以有多个分去对应的task
分组topn:
  1.聚合后按学科进行分组,然后在每个分组中进行排序(调用的Scala集合的排序)
  2.先按学科进行过滤,然后调用RDD的方法进行排序(内存+磁盘+多台机器),需要将任务条件多次
  3.自定义分区,然后在每个分区中进行排序(partitionBy,mapPartitions)
  4.在聚合时就是用聚合分区尅减少分区
  5.自定义分区,mapPartitions在调用mapPartitions的时候定义一个可排序的集合
Wordcount的执行就成
  共6个RDD,2个stage, 不改变RDD的分区时会生成6个task否则生成的task的数量不一定


RDD的另一些方法
  cache(缓存)(程序在退出前再次重复执行时会使用上次执行时的中间结果)[lazy方法]
          将数据存放在内存中可以使数据的读取速度更快
          优点:再次调用时数据的读取速度会快很多
          缺点:第一次使用是会比平时慢
          注:  在cache的数据会在之后反复使用时才会将数据cache到内存中
              标记为cache的RDD被反复的使用才会使用cache(一个进程结束后会被释放掉)
          用法 :{默认使用Java的序列化缺点是占用空间大}
            .cache()
            结束  .unpersist(false)//异步 程序一边释放内存,一边运行
                 .unpersist(true)//同步   程序释放完内存后再运行

          //前面的cache的数据已经被计算完了,后面还有很多其他的指标要计算
          //
      什么是后进行cache
        1.要求计算速度快
        2.集权的资源足够大
        3.重要cache的数据会多次的触发action
        4.先进行过滤,然后将缩小范围的数据再cache到内存中

        OFF_HEAP:堆外内存(tachyon,分布式内存文件系统(该集群中的存储介质均为内存).现改名为alluxio)
  什么叫做checkpoint
      1.场景:多次迭代,要求保证数据安全,对速度要求不高(与cache对比要求不高),将中间结果保存到hdfs中
      再次调用时直接盗用checkpoint指向的中间结果书程序的运行速度提升
      在使用checkpoint目录的要求(使用分布式文件系统,且该文件系统高可用)

      211.201.111.111  IP与归属地映射的作用
      需求: 更具访问日志的IP地址计算出访问者的归属地,并且按照省份,计算出访问次数,然后将计算好的结果下入MySQL

        1.整理数据,且分出IP字段,热后将IP地址转换成十进制
        2.加载规则,整理规则,取出游泳字段,然后将数据缓存到内存中(Executor的内存中)
        3.将访问log与IP规则进行匹配(二分法查找)
        4.取出对应的省份名称,然后将其和1组合在一起
        5.按省份名进行聚合
        6.更具聚合后的数据写入到MySQL中





  reduce.foreachPartition和foreach而区别:
    前者是将一个分区的数据作为一个整体发送,后者是处理完一条数据就发送一次.
    数据量大时reduce.foreachPartition更节省资源
