可变参数方法
  def method1:(str:String,a:Any*)可变参数必须放在参数的最后一个的位置
默认值参数方法  在定义时给参数赋值

部分参数应用参数应用函数
  在定义函数时可以传入部分参数为传入的部分使用占位符占用并且未传入参数的参数类型必须写。
  def add(a:Int,b:Int)=a+b
  val partM=add(5,_:Int)

柯里化 将原来接受接受多个参数的函数变成新的接受一个参数的函数的过程.新的函数返回一个以原有第二个参数为参数的函数
  def addadd(a:Int)(b:Int)=a+b
  add(5)(32)
  def add(a:Int) = (b:Int) => a+b
  val x =add(5)
  x(3)
  结果是8
  高阶函数
    参数势函数或者返回值是函数



偏函数 <函数的参数最多可以有22个>
  偏函数中的判断条件只能用case
  [scala中的没有switch case 但是有match case]
  def func1:PartialFunction[String,Int]([]写的是参数和返回值的类型)={
    case "a"=>97
    case _=>0
  }//参数不符合预期则不处理   模式匹配match case  case可以匹配任意数据（具体的值，类型，class，object，list）
  偏函数有和map相似的功能可以对对各参数同时操作  区别:偏函数可以接受Any类型的参数即参数值类型可以不同 map中的参数值类型需要一致但是map中的参数可以转换成偏函数进行操作
数组定义:  array数组长度不可变内容可变
  val定义出来的数组是内容可变长度不可变的数组/*不可变数组表示长度不可变*/
  var定义的数组长度可变（Array数组除外）,内容可变/*可变数组*/
  整数数组经过map变化后会生成一盒新的数组但是针对原数组无影响(使用原数组变量名接收除外)
  扁平化操作flatten:
    将数组中的数组的元素释放出来使之只有一个数组(共两个数组)
  flatMap   map+flatten
  foreach（f:?）?是由调用者的数据类型决定
最低要求要能看懂函数的签名

大数据工作者在企业 做大数据项目的时间不多跟多的时间是做Javaweb及相关的任务

+--------------------------------------------------------------------------------------------------------------+
                                              下午
+--------------------------------------------------------------------------------------------------------------+
集合:由于集合不属于基本数据类型所以在定义，使用集合时需要导入相应的包
    scala集合的三大类1.Seq 2.Set 3.Map
    mutable(可变集合包)ArrayBuffer内容长度均可变
    imutable(不可变集合包)
    定义上述两类的集合时在定义集合之前
  set 无序不重复
