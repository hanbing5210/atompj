隐式implicit
  隐式转换的好处
    1.定义一次即可在其失效之前一直使用
    2.使代码的编写更加灵活
  隐式可以增强类
  隐式参数：
    在参数前面加implicit即可表示该参数为隐式参数。如果你没有传入参数的话编译器会自动在上下文调用相对应的隐式参数；隐士参数在定义时可以有默认值。
    在柯里化中定义隐式参数可以是代码更加简单
    list.map中的map方法就是隐式参数的例子
    多个implicit定义时在最后一个参数列表中的第一个参数定义即可（最后一组的参数都在一起）在一个程序中隐式编译器在查找隐式值的时候不能有歧，既同一类型的隐式值只能有一个
  隐式类型转换：
    implicit def double2Int(d: Doube)=double.toInt
    在当前上下文找隐式转换函数进行隐式转换
    在转换时会优先去找函数其次在去找方法
    在一个类（类1）中定义一个方法而另一个类（类2）想用则只需要定义一个隐式转换将类2转换成类1即可。
    也可将隐式转换提取成一个类在使用时将该类导入即可使用。
  隐式类
    隐式类 - 只能在单例中使用（既在静态对象中使用）
    scala中农source类可以读文件
    用法Source.fromFile（文件全路径）.mkString
    隐式转换的变量，方法均有下划线标识
泛型：就是类型约束
  约束后面使用的参数的类型是参数的使用更加灵活   定义时泛型使用大写字母代替具体类型
  枚举类型
    在定义时需要继承Ennumeration
类型约束
  类中的比较，要么实现comparable，要么传入比较器comparator
  scala中的标间在底层也是comparator
  上限和下限
    上界： [T <: Test]
    下界：[T >: Test]
    上下界的区别:
      父类是子类的上界.
      如果A约定了最低标准则A称之为下界
    scala中的scala包默认导入
    scala中的代码很灵活   很多底层的东西通过隐式转换如果没有深入一点的研究很多地方的代码看起来就是一头雾水
    视图界定
      <%     T <% Comparable[T]
      视图界定会发生隐式转换,[视图界定和上下界定相比视图界定的代码使用更加灵活,才维护时相对来说更加复杂.]视图界定是和隐式转换相结合使用的
    上下文界定 :
      T : Test
      使视图界定的语法糖,也会发生隐式转换.需要需要一个具体的比较器,含有比较器功能的方法不行.
